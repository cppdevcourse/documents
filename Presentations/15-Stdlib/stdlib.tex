\documentclass[compress, 8pt]{beamer}

\usepackage{presentationtemplate}
\usepackage[askip=3mm, bskip=3mm]{terminal}
\usepackage[linenosfontsize=\tiny, askip=3mm, bskip=3mm]{mylisting}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta}
\usepackage{csquotes}
\usepackage{tabularray}

\newtcolorbox{task}{
    colback=yellow!50!white,
    boxrule=0.02cm,
    colframe=black,
    sharp corners,
    left=0mm,
    right=0mm,
    top=0mm,
    bottom=0mm,
    before upper={\textbf{Задание}:\:},
}

\title{Стандартная библиотека С++}

\begin{document}

  \frame[plain]{\titlepage}

  \begin{frame}[fragile]

    \frametitle{Обзор стандартной библиотеки}

    Стандартная библиотека предоставляет:
    \hfill \break

    \begin{itemize}

      \item средства управления памятью;
      \item структуры данных и алгоритмы для работы с ними;
      \item средства для ввода/вывода;
      \item подмножество часто использумых математических операций;
      \item средства для работы с файловыми системами;
      \item run-time type information (RTTI)\footnote{\url{https://en.cppreference.com/w/cpp/utility/rtti.html}};
      \item средства для параллельных вычислений (на основе потоков или lock-free);
      \item и др.

    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Исполнение стандартной библиотеки}

    Стандартная библиотека состоит из:
    \hfill \break

    \begin{itemize}

      \item заголовочных файлов;
      \item разделяемой библиотеки: libstdc++.so (GNU) и libc++.so (LLVM);
      \item статической библиотеки: libstdc++.a (GNU) и libc++.a (LLVM).
      
    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Линковка со стандартной библиотекой}

    Можно отключить линковку со стандартной библиотекой:

    \begin{mytitledinplacelisting}[minted language=cpp]{main.cpp}
#include <iostream>

int main() {
    std::cout << "Hello, world!\n";
}
    \end{mytitledinplacelisting}

    \begin{terminalwindow}
!\shellcommand{g++ \colorbox{yellow}{-nostdlib++} main.cpp -o main}!
<path>/bin/ld: /tmp/ccm2JkGA.o: in function `main':
main.cpp:(.text+0xa): undefined reference to `std::cout'
<path>/bin/ld: main.cpp:(.text+0xf): undefined reference to `std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)'
collect2: error: ld returned 1 exit status
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Линковка со стандартной библиотекой}

    В большинстве случаев отключать линковку со стандартной библиотекой не требуется.
    Если программа не использует стандартную библиотеку,
    то на размер файла это не повлияет.
    Но может быть важно скомпилировать программу так, чтобы в его динамической
    секции не было стандартной библиотеки.

    \begin{mytitledinplacelisting}[minted language=cpp]{main.cpp}
int main() {
    volatile int* p {};
    *p = 1;
}
    \end{mytitledinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -nostdlib++ main.cpp -o main}!
!\shellcommand{du -sb main}!
!\colorbox{green}{15768}!   main
!\shellcommand{ldd main}!
linux-vdso.so.1 (0x00007f313bbfb000)
...
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Линковка со стандартной библиотекой}

    У скомпилированной без \verb|-nostdlib++| программы тот же размер,
    но без установленной в системе \verb|libstdc++.so.6| она не запустится,
    хотя в ее коде и не требуется код из стандартной библиотеки.

    \begin{terminalwindow}
!\shellcommand{c++ main.cpp -o main}!
!\shellcommand{du -sb main}!
!\colorbox{green}{15768}!   main
!\shellcommand{ldd main}!
linux-vdso.so.1 (0x00007f313bbfb000)
!\colorbox{yellow}{libstdc++.so.6}! => <path>/lib/libstdc++.so.6 (0x00007f313b800000)
...
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Линковка со стандартной библиотекой}

    Со стандартной библиотекой можно слинковаться статически.
    Программа больше не будет зависеть от предустановленной \verb|libstdc++.so|,
    но вырастет в размере.

    \begin{terminalwindow}
!\shellcommand{c++ main.cpp -o dynamic}!
!\shellcommand{du -sh dynamic}!
!\colorbox{green}{16K}!     dynamic
!\shellcommand{c++ \colorbox{yellow}{-static-libstdc++} main.cpp -o static}!
!\shellcommand{du -sh static}!
!\colorbox{pink}{1,4M}!    static
!\shellcommand{ldd static}!
linux-vdso.so.1 (0x00007f57eadc2000
...
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Standard template library (STL)}

    В стандартной библиотеке выделяют часть, которая называется
    \textit{Standard template library}\footnotemark{} (STL).
    По большей части она представляет собой набор шаблонов классов и функций
    с параметром-типом.

    \footnotetext{\url{https://en.wikipedia.org/wiki/Standard\_Template\_Library}}

    \hfill \break
    STL состоит из:

    \begin{itemize}
      \item контейнеров;
      \item итераторов;
      \item алгоритмов.
    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{STL: контейнеры}

    Контейнеры для структур данных с последовательным доступом.
    Доступ к элементам имеет асимптотическую сложность
    $O\left(1\right)$ для контейнеров с последовательным расположением
    элементов и $O\left(n\right)$ для остальных.
    \hfill \break

    \begin{tblr}{
      colspec = {|X[0.3,l]|X[0.7,l]|},
      row{1} = {font=\bfseries},
      hlines, vlines,
      rowsep = 0.8ex,
      colsep = 1.0ex,
    }
      Контейнер & Описание \\
      \texttt{array} & Массив с размером, известным во время компиляции. \\
      \texttt{vector} & Динамический массив. \\
      \texttt{deque} & Двухсторонняя очередь. \\
      \texttt{forward\_list} & Односвязный список. \\
      \texttt{list} & Двусвязный список. \\
    \end{tblr}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{STL: контейнеры}

    Ассоциативные контейнеры хранят данные в сортированном виде,
    поиск по ним имеет $O\left(log\left(n\right)\right)$ асимптотическую
    сложность.
    \hfill \break

    \begin{tblr}{
      colspec = {|X[0.3,l]|X[0.7,l]|},
      row{1} = {font=\bfseries},
      hlines, vlines,
      rowsep = 0.8ex,
      colsep = 1.0ex,
    }
      Контейнер & Описание \\
      \texttt{set} & Коллекция уникальных ключей. \\
      \texttt{map} & Коллекция пар ключ-значение, ключи уникальны. \\
      \texttt{multiset} & Коллекция ключей. \\
      \texttt{multimap} & Коллекция пар ключ-значение. \\
    \end{tblr}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{STL: контейнеры}

    Ассоциативные несортированные контейнеры используют хэширование
    для определения расположения элемента,
    поиск по ним имеет $O\left(1\right)$ асимптотическую
    сложность.
    \hfill \break

    \begin{tblr}{
      colspec = {|X[0.3,l]|X[0.7,l]|},
      row{1} = {font=\bfseries},
      hlines, vlines,
      rowsep = 0.8ex,
      colsep = 1.0ex,
    }
      Контейнер & Описание \\
      \texttt{unordered\_set} & Коллекция уникальных ключей. \\
      \texttt{unordered\_map} & Коллекция пар ключ-значение, ключи уникальны. \\
      \texttt{unordered\_multiset} & Коллекция ключей. \\
      \texttt{unordered\_multimap} & Коллекция пар ключ-значение. \\
    \end{tblr}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{STL: контейнеры}

    Иные контейнеры:
    \hfill \break

    \begin{tblr}{
      colspec = {|X[0.3,l]|X[0.7,l]|},
      row{1} = {font=\bfseries},
      hlines, vlines,
      rowsep = 0.8ex,
      colsep = 1.0ex,
    }
      Контейнер & Описание \\
      \texttt{string} & Строка. \\
      \texttt{stack} & LIFO структура (стек). \\
      \texttt{queue} & FIFO структура (односторонняя очередь). \\
      \texttt{span} &
      Невладеющий контейнер последовательно расположенных в памяти элементов
      (C++20). \\
    \end{tblr}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{\texttt{std::array}}

    Элементы \texttt{std::array}\footnotemark{} располагаются на стеке.
    Этот шаблон имеет второй параметр-константу, которая определяет размер
    массива.

    \footnotetext{\url{https://en.cppreference.com/w/cpp/container/array.html}}

    \begin{myinplacelisting}[minted language=cpp]
#include <array>
#include <cstddef>
#include <print>

struct Foo {};

std::size_t foo() { return 30; }
constexpr std::size_t bar() { return 50; }

int main() {
    std::array<int, 3> arr0 {1, 2, 3};
    std::array<int, foo()> arr1 {}; // compile error
    std::array<Foo, bar()> arr2 {};

    std::println("size: {}", arr0.size()); // prints 3
    std::println("empty: {}", arr0.empty()); // prints 'false'
}
    \end{myinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Доступ к элементам \texttt{std::array}}

    Доступ к элементам массива возможен через оператор \verb|[]|
    и \\ метод \texttt{at}.
    Последний генерирует исключение, когда индекс выходит
    за границы массива.

    \begin{task}
      Порассуждайте о преимуществах и недостатках метода \texttt{at}.
    \end{task}

    \begin{myinplacelisting}[minted language=cpp]
#include <array>
#include <print>
#include <stdexcept>

int main() {
    const std::array<int, 3> arr {1, 2, 3};

    try {
        std::println("{}", arr[100]); // prints garbage, UB
        std::println("{}", arr.data()[100]); // same UB
        std::println("{}", arr.at(100)); // throws
    }
    catch (const std::out_of_range& err) {
        std::println("Error: {}", err.what());
    }
}
    \end{myinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Псевдонимы типов \texttt{std::array}}

    В шаблонах-контейнеров обычно определен набор из псевдонимов.

    \begin{mycppinplacelisting}
#include <array>

int main() {
    using Array = std::array<int, 0u>;

    Array::value_type i = 0; // int
    Array::size_type s = 0u; // std::size_t
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Range-based цикл \texttt{for} и контейнеры}

    Совместно STL контейнерами можно использовать вариацию циклa \texttt{for},
    которая называется \textit{range-based for loop}\footnotemark{}.

    \footnotetext{\url{https://en.cppreference.com/w/cpp/language/range-for.html}}

    \begin{myinplacelisting}[minted language=cpp]
#include <array>
#include <print>

int main() {
    std::array<int, 3> arr {3, 2, 1};

    for (int& i : arr) {
        i += 1;
    }

    for (const int i : arr) {
        std::println("i = {}", i);
    }
}
    \end{myinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Range-based цикл \texttt{for} и пользовательские типы}

    Range-based цикл можно использовать не только с контейнерами.
    Ожидается, что типы, используемые в этом цикле, имеют определенный
    набор методов.

    \begin{mycppinplacelisting}
#include <print>

struct Foo {
    int* begin() { return &values[0]; }
    int* end() { return &values[2] + 1; }
private:
    int values[3] = {1, 2, 3};
};

int main() {
    Foo foo {};

    for (auto value : foo) {
        std::println("value = {}", value);
    }
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{\texttt{std::vector}}

    Элементы \texttt{std::vector}\footnotemark{} расположены в куче последовательно.
    Большинство методов \texttt{std::array} имеют смысл и для вектора,
    они объявлены с теми же именами.

    \footnotetext{\url{https://en.cppreference.com/w/cpp/container/vector.html}}

    \begin{mycppinplacelisting}
#include <print>
#include <vector>

int main() {
    std::vector<int> v {1, 2, 3};

    std::println("size: {}", v.size());
    std::println("max_size: {}", v.max_size());
    std::println("empty: {}", v.empty());
    std::println("data: {}", (void*){v.data()});

    std::println("v[0]: {}", v[0]);
    std::println("v.at(0): {}", v.at(0));
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Изменение размера \texttt{std::vector}}

    В отличие от \texttt{std::array}, вектор может изменять
    свой размер.

    \begin{task}
      Поразмышляйте, что выведет программа и почему?
      Метод \texttt{data} возвращает адрес первого элемента
      вектора в куче.
    \end{task}

    \begin{mycppinplacelisting}
#include <print>
#include <vector>

int main() {
    std::vector<int> v {1, 2, 3};

    std::println("data: {}", (void*){v.data()});

    v.resize(100);

    std::println("data: {}", (void*){v.data()});
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Ёмкость \texttt{std::vector}}

    Для вектора, помимо размера, определено понятие \textit{ёмкости}.
    \hfill \break

    \begin{itemize}
      \item Размер \textemdash \space количество элементов в векторе.
      \item Ёмкость \textemdash \space характеризует размер непрерывного
        участка памяти в куче, в котором хранятся элементы вектора.
    \end{itemize}
    \hfill \break

    Управление ёмкостью вектор происходит в полуавтоматическом режиме:
    некоторые методы приводят к изменению ёмкости косвенно,
    некоторые \textemdash \space напрямую.

    \begin{task}
      Поразмышляйте, зачем потребовалось вводить понятие ёмкости? 
    \end{task}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Изменение ёмкости \texttt{std::vector}}

    Ёмкость вектора растет при добавлении нового элемента массива,
    но не обязательно на размер его элемента.
    При удалении элемента из массива ёмкость не уменьшается.

    \begin{mycppinplacelisting}
int main() {
    std::vector<int> v {};
    std::println("size: {}, capacity: {}",
        v.size(), v.capacity());

    for (int i = 0; i < 5; i++) {
        v.push_back(i); // add element to the end of vector
        std::println("size: {}, capacity: {}",
            v.size(), v.capacity());
    }

    while (!v.empty()) {
        v.pop_back(); // remove last element from vector
        std::println("size: {}, capacity: {}",
            v.size(), v.capacity());
    }
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Изменение ёмкости \texttt{std::vector}}

    Вывод программы с листинга на прошлом слайде:

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
size: 0, capacity: 0
size: 1, capacity: 1
size: 2, capacity: 2
size: 3, capacity: 4
size: 4, capacity: 4
size: 5, capacity: 8
size: 4, capacity: 8
size: 3, capacity: 8
size: 2, capacity: 8
size: 1, capacity: 8
size: 0, capacity: 8
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Ручное управление ёмкостью \texttt{std::vector}}

    Пример ручного управления ёмкостью вектора:

    \begin{mycppinplacelisting}
#include <print>
#include <vector>

bool condition();

int main() {
    std::vector<int> v {};
    v.reserve(10); // expand capacity to 10 elements

    for (int i = 0; i < 10 && condition(); i++) {
        v.push_back(i); // no reallocations!
    }

    v.shrink_to_fit(); // free unused memory
}
    \end{mycppinplacelisting}

    \begin{task}
      Подумайте, какие недостатки могут быть у метода \verb|shrink_to_fit|?
    \end{task}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Удаление элемента \texttt{std::vector}}

    Для удаления произвольного элемента используется метод
    \texttt{erase}.
    Он принимает \textit{итератор}\footnotemark{}, который
    указывает на удаляемый элемент.

    \footnotetext{Определение итератора дается позднее.}

    \begin{mycppinplacelisting}
using Vector = std::vector<int>;

void print(const Vector& v) {
    std::println("data:\t{}", (const void*){v.data()});
    std::println("size:\t{}", v.size());
    std::print("vector:\t");
    for (auto it : v) { std::print("{} ", it); }
    std::println();
}

int main() {
    std::vector<int> v {1, 2, 3, 4, 5};
    print(v);
    v.erase(v.cbegin() + 1);
    print(v);
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Удаление элемента \texttt{std::vector}}

    Вывод программы с листинга на прошлом слайде:

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
data:   !\colorbox{green}{0x5627d277f2b0}!
size:   5
vector: 1 2 3 4 5
data:   !\colorbox{green}{0x5627d277f2b0}!
size:   4
vector: 1 3 4 5
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    Для иллюстрации того, что происходит с элементами \texttt{std::vector} \\
    при вызове различных модифицирующих методов, определим класс
    \texttt{Pirate}.

    \begin{mycppinplacelisting}
struct Pirate {
    // ...
    Pirate(std::string_view name) noexcept : name(name) {}
    Pirate(const Pirate& o) noexcept : name(o.name) {
        std::println("Copy {}", name);
    }
    Pirate& operator=(const Pirate& o) noexcept {
        std::println("{} copy assignment", name);
        // ...
    }
    Pirate(Pirate&& o) noexcept : name(std::move(o.name)) {
        std::println("Move {}", name);
    }
    Pirate& operator=(Pirate&& o) noexcept {
        std::println("{} move assignment", name);
        // ...
    }
    std::string name;
};
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    \begin{task}
      Объясните ошибку компиляции в коде на листинге ниже.
    \end{task}

    \begin{mycppinplacelisting}
struct Pirate {
    Pirate() = delete;
    // ...
};

int main() {
    std::vector<Pirate> v;
    v.resize(10); // compile error
}
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    Если конструктор перемещения не объявлен \texttt{noexcept},
    то компилятор будет по-умолчанию использовать копирование
    при изменении размера вектора.

    \begin{mycppinplacelisting}
struct Pirate {
    // ...
    Pirate(Pirate&& o) : name(std::move(o.name)) {/*...*/}
};

int main() {
    std::vector<Pirate> v {Pirate{"Jack"}, Pirate{"Hector"}};
    v.resize(4);
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Copy Jack
Copy Hector
Copy Jack
Copy Hector
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    \begin{mycppinplacelisting}
struct Pirate {
    // ...
    Pirate(Pirate&& o) |\colorbox{yellow}{noexcept}| : name(std::move(o.name))
    {/*...*/}
};

int main() {
    std::vector<Pirate> v {Pirate{"Jack"}, Pirate{"Hector"}};
    v.resize(4);
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Copy Jack
Copy Hector
Move Jack
Move Hector
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    \begin{task}
      Объясните вывод программы.
    \end{task}

    \begin{mycppinplacelisting}
int main() {
    std::vector<Pirate> v = {
        Pirate{"Jack"}, Pirate{"Hector"},
        Pirate{"Davy"}, Pirate{"Joshamee"}
    };
    v.erase(v.cbegin() + 2);
    v.erase(v.cbegin() + 2);
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Copy Jack
Copy Hector
Copy Davy
Copy Joshamee
Joshamee move assignment
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    Для вставки элементов можно использовать метод \texttt{insert}.

    \begin{task}
      Объясните вывод программы.
    \end{task}

    \begin{columns}[T]

      \begin{column}{0.5\textwidth}
        
        \begin{mycppinplacelisting}
int main() {
    std::vector<Pirate> v = {
        Pirate{"Jack"},
        Pirate{"Davy"},
        Pirate{"Joshamee"}
    };
    v.insert(v.cbegin() + 1,
        Pirate{"Hector"});
}
        \end{mycppinplacelisting}

      \end{column}
      
      \begin{column}{0.5\textwidth}
        
        \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp}!
!\shellcommand{./a.out}!
Copy Jack
Copy Davy
Copy Joshamee
Move Hector
Move Jack
Move Davy
Move Joshamee
        \end{terminalwindow}

      \end{column}
      
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    \begin{task}
      Объясните вывод программы.
    \end{task}

    \begin{columns}[T]

      \begin{column}{0.5\textwidth}
        
        \begin{mycppinplacelisting}
int main() {
    std::vector<Pirate> v = {
        Pirate{"Jack"},
        Pirate{"Davy"},
        Pirate{"Joshamee"}
    };
    const Pirate hector
        { "Hector" };
    v.insert(v.cbegin() + 1,
         std::move(hector));
}
        \end{mycppinplacelisting}

      \end{column}
      
      \begin{column}{0.5\textwidth}
        
        \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp}!
!\shellcommand{./a.out}!
Copy Jack
Copy Davy
Copy Joshamee
Copy Hector
Move Jack
Move Davy
Move Joshamee
        \end{terminalwindow}

      \end{column}
      
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Время жизни элементов \texttt{std::vector}}

    Для конструирования объектов прямо в куче можно использовать
    метод \texttt{emplace}.

    \begin{columns}[T]

      \begin{column}{0.5\textwidth}
        
        \begin{mycppinplacelisting}
int main() {
    std::vector<Pirate> v = {
        Pirate{"Jack"},
        Pirate{"Davy"},
        Pirate{"Joshamee"}
    };
    v.emplace(v.cbegin() + 1,
         "Hector");
}
        \end{mycppinplacelisting}

      \end{column}
      
      \begin{column}{0.5\textwidth}
        
        \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp}!
!\shellcommand{./a.out}!
Copy Jack
Copy Davy
Copy Joshamee
Move Jack
Move Davy
Move Joshamee
        \end{terminalwindow}

      \end{column}
      
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Специализация \texttt{std::vector<bool>}}

    Для \texttt{std::vector} определена частичная специализация
    для типа \texttt{bool}.
    В этой специализации каждый элемент занимает ровно один байт.

    \hfill \break
    Многими эта специализация рассматривается как архитектурная ошибка
    в стандарте.

    \begin{mycppinplacelisting}
std::vector<bool> v = {
    true, true, true, true,
    false, false, false, false,
    true, true, true, true,
    false, false, false, false
};

bool& b = v[0]; // compile error
bool* pb = &v[0]; // compile error
bool* pb1 = v.data(); // compiler error
    \end{mycppinplacelisting}

    \begin{task}
      Почему это решение считается неудачным?
      Какие есть альтернативы для представления массива
      байт?
    \end{task}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{\texttt{std::list}}

    В случаях, когда операции удаления/вставки планируются частыми,
    а непрерывность расположения элементов в памяти не так важна,
    лучше воспользоваться двусвязным списком \texttt{std::list}\footnotemark{}.

    \footnotetext{\url{https://en.cppreference.com/w/cpp/container/list.html}}

    \begin{columns}[T]

      \begin{column}{0.6\textwidth}
        
        \begin{mycppinplacelisting}
int main() {
    std::list<Pirate> l = {
        Pirate{"Jack"},
        Pirate{"Davy"},
        Pirate{"Joshamee"}
    };
    auto pos =
      std::next(l.cbegin(), 1);
    l.insert(pos, Pirate{"Hector"});
    l.erase(std::next(pos, 1));
}
        \end{mycppinplacelisting}

      \end{column}
      
      \begin{column}{0.4\textwidth}
        
        \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp}!
!\shellcommand{./a.out}!
Copy Jack
Copy Davy
Copy Joshamee
Move Hector
        \end{terminalwindow}

      \end{column}
      
    \end{columns}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{\texttt{std::set}}

    Для хранения набора уникальных значений можно использовать
    \texttt{std::set}\footnote{\url{https://en.cppreference.com/w/cpp/container/set.html}}.
    Обычно \texttt{std::set} реализован как красно-черное
    дерево\footnote{\url{https://en.wikipedia.org/wiki/Red\%E2\%80\%93black\_tree}}.

    \hfill \break
    \enquote{Уникальность} значений в \texttt{std::set} проверяется оператором
    \texttt{<} (\enquote{меньше}).
    Для двух элементов \texttt{std::set} $a$ и $b$ никогда не должно быть
    истонно выражение:

    \begin{equation*}
      \neg \left(a < b\right) \land \neg \left(b < a\right)
    \end{equation*}

    \hfill \break
    \begin{task}
      Почему обязательным требованием к типам в \texttt{std::set} является
      именно оператор \texttt{<}, а не \texttt{==}?
    \end{task}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Сортировка в \texttt{std::set}}

    \begin{mycppinplacelisting}
struct Pirate {
    std::string name;
    bool operator<(const Pirate& o) const noexcept {
        return name < o.name;
    }
};

int main() {
    std::set<Pirate> s = {
        Pirate{"Jack"}, Pirate{"Davy"},
        Pirate{"Joshamee"}, Pirate{"Hector"}
    };

    for (const auto& it: s) std::print("{} ", it.name);
    std::println();
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Davy Hector Jack Joshamee
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Сортировка в \texttt{std::set}}

    Алгоритм сортировки можно определять отдельно от типа-значения.
    Для этого надо определить тип-компаратор.

    \begin{mycppinplacelisting}
struct Pirate { std::string name; };

struct Alphabet {
    bool operator()(const Pirate& l, const Pirate& r) const {
        return l.name < r.name;
    }
};

struct ReverseAlphabet {
    bool operator()(const Pirate& l, const Pirate& r) const {
        return l.name > r.name;
    }
};
    \end{mycppinplacelisting}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Сортировка в \texttt{std::set}}

    Тип-компаратор затем можно использовать вторым аргументом
    шаблона.

    \begin{mycppinplacelisting}
int main() {
    std::set<Pirate, Alphabet> s0 = {
        Pirate{"Jack"}, Pirate{"Davy"},
        Pirate{"Joshamee"}, Pirate{"Hector"}
    };
    print(s0);
    std::set<Pirate, ReverseAlphabet> s1 = {
        Pirate{"Jack"}, Pirate{"Davy"},
        Pirate{"Joshamee"}, Pirate{"Hector"}
    };
    print(s1);
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Davy Hector Jack Joshamee
Joshamee Jack Hector Davy
    \end{terminalwindow}

  \end{frame}

  \begin{frame}[fragile]

    \frametitle{Сортировка в \texttt{std::set}}

    Неправильно написанный компаратор может привести к неожиданным
    и нежелательным последствиям.

    \begin{mycppinplacelisting}
struct BadComparator {
    bool operator()(const Pirate& l, const Pirate& r) const {
        return l.name != r.name;
    }
};

int main() {
    std::set<Pirate, BadComparator> s = {
        Pirate{"Jack"}, Pirate{"Davy"},
        Pirate{"Joshamee"}, Pirate{"Hector"}
    };
    for (const auto& it: s) std::print("{} ", it.name);
}
    \end{mycppinplacelisting}

    \begin{terminalwindow}
!\shellcommand{c++ -std=c++23 main.cpp -o main && ./main}!
Davy Jack
    \end{terminalwindow}

  \end{frame}

\end{document}
